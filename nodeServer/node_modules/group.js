function Group(mysql_pool, existingCategories, pointScale, data){
    //mysql connection pool
    this.mysql_pool = mysql_pool;
    
    //list of clients that are connected to this group session
    this.clients = {};
    
    //list of all category types
    this.existingCategories = existingCategories;
    
    //the pointScale used to reward points for correct answers
    this.pointScale = pointScale;
    
    //required percentage of clients to skip question
    this.requiredVotePercentage = 50;
    
    //holds the clientIDs of those who vote to skip
    this.skipVotes = {};
    
    //required percentage to move on to the next question
    this.requiredAnswerPercentage = 66;
        
    //this will make it so the group can submit or can't submit answers
    //example usage: when they are skipping a question, don't let them
    //continue to submit answers.
    this.canSubmitAnswers = true;
        
    //current data
    this.timer = 0;
    this.timerInit = 0;
    this.guestCount = 0;
    this.currentQuestion = {
        question : {},
        answers : {}
    };
    this.submittedAnswers = [];
    
    //group data
    this.id = data.id;
    this.creator = data.creator;
    this.name = data.name;
    this.hash = data.hash;
    this.date_created = data.date_created;
    this.categories = data.categories;
    this.amount_correct = data.amount_correct;
    this.points = data.points;
    this.isPrivate = data['private']; //private jerbascript keyword
    this.max_time = data.max_time;
    this.answered = [];
    this.total_answered = 0;
    
    //defines whether the group has been initialized. so if someone
    //joins after the init of this group, we can check this variable.
    this.loadedReady = false;
    
    //the countdown timer
    this.betweenTimeout = false;
    
    
    //remember, everything is async. So in order to load event after event,
    //we will need to use callback. This will load all the data before sending
    //anything to the client.
    var self = this;
    this.getAnsweredQuestions(function(returned){
        if(returned)
            self.loadNextQuestion(function(returned){
                if(returned)
                    self.ready();
                else
                    self.throwError('There are no available questions to answer for this group.');
            });
    });
}

/*
 *  Main loop
 */
Group.prototype.main = function(){
    var self = this;
    var seconds = this.max_time*60;
    
    if(this.max_time > 0){
        this.startTimer(seconds);
        
        this.mainTimeout = setTimeout(function(){
            self.questionDone();
        }, seconds*1000);
    }
}

/*
 *  Checks if the question is complete, if so, continue
 */
Group.prototype.checkIfQuestionDone = function(){
    var answers = this.submittedAnswers.length;
    var clients = this.getClientCount();
    var percent = (answers/clients)*100;
    
    //has the minimum requirement of answers been met?
    if(clients > 0 && percent >= this.requiredAnswerPercentage)
        this.questionDone();
}

/*
 *  This will start everything over with a new question.
 *  !!!SEND THE NEXT QUESTION, IS NOT JUST PREPARATION
 */
Group.prototype.questionDone = function(){
    var self = this;
    
    var questionID = this.currentQuestion.question.id;
    
    //update current data
    this.total_answered++;
    this.answered.push(questionID);
    
    //get & send the correct answer
    var letters = ['a','b','c','d','e'];
    var correct_answer = this.currentQuestion.question.correct_answer;
    var answerIndex = this.currentQuestion.ids.indexOf(correct_answer);
    var correctAnswerLetter = letters[answerIndex];
    var correctAnswerID = this.currentQuestion.ids[answerIndex];
    var groupAnswerID = 0;
    
    //send the correct answer to the clients
    this.send('correctAnswer', correctAnswerLetter);
    
    //did the group get the answer right, though?
    var groupAnswer = this.getGroupAnswer().answers;
    
    if(groupAnswer.indexOf(correctAnswerLetter) >= 0){
        //they got it correct!
        this.amount_correct++;
        this.groupCorrect(this.currentQuestion.question.difficulty);
        groupAnswerID = correctAnswerID;
    }else{
        groupAnswerIndex = letters.indexOf(groupAnswer[0]);
        groupAnswerID = this.currentQuestion.ids[groupAnswerIndex];
    }
    
    //now lets mark this question "answered" for this group
    //so they don't ever get this question again
    this.markQuestionAnswered(groupAnswerID, questionID);
    
    this.loadNextQuestion(function(returned){
        self.canSubmitAnswers = false;
        self.endTimer();
        self.startTimer(15);
        self.betweenTimeout = setTimeout(function(){
            if(returned){
                if(self.max_time > 0)
                    self.main();
                
                self.sendCurrentQuestion();
                self.sendAnswerStats();
                self.canSubmitAnswers = true;
            }else{
                self.throwError('There are no available questions to answer for this group.');
            }
            
            //mark "betweenTimeout" as false. there is no timer active
            self.betweenTimeout = false;
        },15000);
    });
}

/*
 *  Receivess the answer one of the clients has submitted for
 *  the current question. Proccess this answer
 */
Group.prototype.handleAnswer = function(client, answer){
    //can the group submit answers at this time?
    if(this.canSubmitAnswers){
        var possibleAnswers = ['a', 'b', 'c', 'd', 'e'];
    
        /*
        *  serves two purposes
        *  1) make sure they submit a legit answer that is within possibleAnswers
        *  2)  gets the index of the answer from this array, which can then use to
        *      compare to the list of answer ids in the "ids array, to get the
        *      corresponding answer ID
        */ 
        var answerIndex = possibleAnswers.indexOf(answer);

        if(answerIndex >= 0){
            answerID = this.currentQuestion.ids[answerIndex];

            var hasAnswered = this.getClientProp(client, 'answered');

            if(hasAnswered){
                this.submittedAnswers[hasAnswered-1] = [
                    answer,
                    answerIndex,
                    answerID
                ];
            }else{
                //update stored answers on the current question
                this.submittedAnswers.push([
                    answer,
                    answerIndex,
                    answerID
                ]);

                //mark them as "answered" so they can't send more questions
                //we will mark their answer array position, so if they ever change their
                //answer, we can!
                this.setClientProp(client, 'answered', this.submittedAnswers.length);
                this.checkIfQuestionDone();
            }

            this.sendAnswerStats();
        }
    }
}

/*
 * Gets the answer data
 */
Group.prototype.getAnswerStats = function(){
    var self = this;
    
    var list = {
        a : 0,
        b : 0,
        c : 0,
        d : 0,
        e : 0,
        clients : self.getClientCount()
    };
    
    var submittedAnswers = this.submittedAnswers;
    for(var ans in submittedAnswers)
        list[submittedAnswers[ans][0]]++;
    
    return list;
}

/*
 *  Gets the most chosen answer, and accepts it
 *  as the answer for the group
 */
Group.prototype.getGroupAnswer = function(){
    var stats = this.getAnswerStats();
    
    //answers is an array, in case there is
    //a tie!
    var answer = {
        votes : 0,
        answers : []
    };
    
    for(var ans in stats){
        if(ans != 'clients'){
            //amount of people who chose this answer
            var votes = stats[ans];
            
            if(votes > answer.votes){
                answer.votes = votes;
                answer.answers = [ans];
            }else if(votes >= answer.votes){
                answer.votes = votes;
                answer.answers.push(ans);
            }
        }
    }
    
    return answer;
}

/*
 *  Sends answer data to clients
 */
Group.prototype.sendAnswerStats = function(){
    this.send('answerData', this.getAnswerStats());
}

/*
 *  An event-after-event loading of the next question.
 *  It will grab a random question, and then it will move on after that
 *  query to load the answers that go along with it
 *  
 *  opID : optional question ID to omit from search results
 *  
 *  !!!ONLY PREPARES THE DATA! DOES NOT SEND DATA!
 */
Group.prototype.loadNextQuestion = function(callback, opID){
    var self = this;

    self.getRandomQuestion(function(q){
        if(q)
            self.getAnswerData([q.a1, q.a2, q.a3, q.a4, q.a5], function(returned){
                if(returned){
                    //the question has been loaded
                    //the question's answers have been loaded
                    self.submittedAnswers = [];
                    
                    if(callback) callback(true);
                }
            });
        else
            callback(false);
    }, opID);
}

/*
 *  Gets all the questions that the group has already answered
 */
Group.prototype.getAnsweredQuestions = function(callback){
    var self = this;
    
    var sql = "SELECT DISTINCT `questionID` FROM `groups_answers` WHERE `groupID` = ?";
    this.mysql_pool.getConnection(function(err, conn){
        if(!err){
            conn.query(sql, [self.id], function(err, r){
                conn.release();
                
                if(!err){
                    //set total # of questions this group has answered
                    self.total_answered = r.length;
                    
                    //for each distinct question id that has already been answered
                    //we can add to the parent's "answered" array
                    for(var i = 0; i < r.length; i++)
                        self.answered.push(r[i].questionID);
                    
                    if(callback) callback(r);
                }else{
                    console.log('group.getAnsweredQuestions() [query]: '+err);
                }
            });
        }else{
            console.log('group.getAnsweredQuestions() [conn]: '+err);
        }
    });
}

/*
 *  Let's get a RANDOM question from the questions table
 *  Ignore questions the group has already
 */
Group.prototype.getRandomQuestion = function(callback, opID){
    var self = this;
    
    var answered = this.answered;
    var categories = this.categories.split(',');
    
    if(typeof opID != 'undefined')
        answered.push(opID);
    
    //will throw an SQL error if we throw an empty string in NOT IN ( )
    //this happens when a new group is formed, and they have 0 answered
    if(answered.length == 0)
        answered.push(0);
    
    answered = answered.join(",");
    
    var sql = "SELECT * FROM `questions` WHERE ( `id` NOT IN ("+ answered +") AND `category` IN ("+ categories +") ) ORDER BY RAND() LIMIT 1";
    
    this.mysql_pool.getConnection(function(err, conn){
        if(!err){
            conn.query(sql, function(err, r){
                conn.release();
                
                if(!err){
                    if(r.length > 0){
                        //row data lies in r[0]
                        r = r[0];

                        self.currentQuestion['question'] = r;

                        if(callback) callback(r);
                    }else{
                       callback(false); 
                    }
                }else{
                    console.log('group.getRandomQuestion() [query]: '+err);
                }
            });
        }else{
            console.log('group.getRandomQuestion() [conn]: '+err);
        }
    });
}

/*
 *  Gets all the answers that are associated with a question
 */
Group.prototype.getAnswerData = function(ids, callback){
    var self = this;
    
    var sql = "SELECT `id`,`answer` FROM `answers` WHERE `id` IN (?) ORDER BY `id` ASC LIMIT 5";
    
    this.mysql_pool.getConnection(function(err, conn){
        if(!err){
            conn.query(sql, [ids], function(err, r){
                conn.release();
                
                if(!err){
                    //we split up the ids and answers into two different properties
                    //so we can send the answer data without the ids. the clients
                    //should not be able to see the answer ids
                    self.currentQuestion.ids = [];
                    self.currentQuestion.answers = [];
                    
                    //add answer to answer array in (id=>answer) format
                    for(var a in r){
                        self.currentQuestion.ids.push(r[a].id);
                        self.currentQuestion.answers.push(r[a].answer);
                    }
                    
                    if(callback) callback(r);
                }else{
                    console.log('group.getAnswers() [query]: '+err);
                }
            });
        }else{
            console.log('group.getAnswers() [conn]: '+err);
        }
    }); 
}

/*
 *  Add the question to the "groups_answers" table so the group
 *  wont repeat the same question
 */
Group.prototype.markQuestionAnswered = function(answerID, questionID){
    var self = this;
    
    var sql = "INSERT INTO `groups_answers` VALUES (?,?,?)";
    this.mysql_pool.getConnection(function(err, conn){
        if(!err){
            conn.query(sql, [self.id, answerID, questionID], function(err){
                conn.release();
                
                if(err)
                    console.log('group.markQuestionAnswered() [query]: '+ err);
            });
        }else{
            console.log('group.markQuestionAnswered() [conn]: '+err);
        }
    });
}

/*
 *  Takes the data of the current question and packs it
 *  into one object that can be sent
 */
Group.prototype.getCurrentQuestion = function(){
    var self = this;
    var q = this.currentQuestion.question;
    var a = this.currentQuestion.answers;
    
    return {
        q : {
            question : q.question,
            extra_info : q.extra_info,
            category : self.existingCategories[q.category],
            difficulty : q.difficulty,
            correct : q.times_correct,
            incorrect : q.times_incorrect,
            avg : q.average_time_seconds
        },
        answers : a,
        stats : {
            amount_correct : self.amount_correct,
            total_answered : self.total_answered
        }
    };
}

/*
 *  Packs & Send the current question to the clients
 */
Group.prototype.sendCurrentQuestion = function(){
    this.setAllClientProps('answered', false);
    this.send('setQuestion', this.getCurrentQuestion());
}

/*
 *  Gets the group data that is safe to send to the client
 */

Group.prototype.getGroupData = function(){
    var self = this;
    return {
        name : self.name,
        categories : self.categories,
        amount_correct : self.amount_correct,
        total_answered : self.total_answered,
        max_time : self.max_time,
        isPrivate : self.isPrivate,
        currentVisitors : self.getClientCount()
    };
}

/*
 *  Update amount_correct & give them their points!
 */
Group.prototype.groupCorrect = function(difficulty){
    var self = this;
    var points = this.pointScale[difficulty];
    
    var sql = "UPDATE `groups` SET `points` = `points` + ?, `amount_correct` = `amount_correct` + 1  WHERE `id` = ? LIMIT 1";
    
    this.mysql_pool.getConnection(function(err, conn){
        if(!err){
            conn.query(sql, [points, self.id], function(err){
                conn.release();
                
                if(err)
                    console.log('group.groupCorrect() [query]: '+ err);
            });
        }else{
            console.log('group.groupCorrect() [conn]: '+err);
        }
    });
}

/*
 *  Sends specified event and data to all clients
 */
Group.prototype.send = function(event, data){
    var self = this;
    for(var client in this.clients){
        if(typeof self.clients[client] != null)
            self.clients[client].emit(event, data);
    }
}

/*
 *  Send to all clients except the broadcaster
 */

Group.prototype.broadcast = function(client, event, data){
    var self = this;
    for(var c in this.clients){
        if(typeof self.clients[c] != null && self.clients[c].id != client.id)
            self.clients[c].emit(event, data);
    }
}

/*
 *  When someone joins the group page, the client is added here
 *  so we can keep track of who we are sending info/packets to
 *  Gives them a name, too!
 */
Group.prototype.addClient = function(client){
    if(!this.thrownError){
        //unique numbers for each Guest
        //e.g.: Guest_1, Guest_2
        this.guestCount++;

        this.clients[client.id] = client;
        this.clients[client.id].username = 'Guest_'+ this.guestCount;
        this.clients[client.id].lastChatMessage = 0;
        this.clients[client.id].answered = false;

        //they are joining after the group has been init, so we
        //need to send the init data to this client too
        if(this.loadedReady){
            client.emit('setQuestion', this.getCurrentQuestion());
            client.emit('ready', this.getGroupData());
            this.sendAnswerStats();
        }
        
        //is there a timer in progress?
        var curTime = new Date().getTime();
        var timeTarget = this.timeInit+(this.timer*1000);
        var timeRemaining = this.timer-((curTime-this.timeInit)/1000);
        
        //timer is in progress. start the timer for the client
        if(this.timer > 0 && curTime < timeTarget)
            client.emit('timer', Math.round(timeRemaining));

        //attach eventlisteners to the client now, for communications
        //between the client and the server
        this.addEventListeners(client);
    }else{
        client.emit('anError', this.thrownError);
    }
}

/*
 *  Remove a client from the session
 *  Generates a new client list excluding the removed client
 */
Group.prototype.removeClient = function(client){
    var clients = this.clients;
    
    //new list that we will use after we remove clients
    var newClientList = {};
    
    for(var c in clients){
        if(clients[c].id != client.id && clients[c] != null)
            newClientList[c] = clients[c];
    }
    
    this.clients = newClientList;
    
    //do they have a vote to skip? if so, remove it.
    if(this.skipVotes[client.id])
        this.skipVotes[client.id] = false;
    
    //now we need to update everybody's answer data
    this.sendAnswerStats();
    
    if(this.getClientCount() == 0)
        this.checkIfQuestionDone();
    else
        this.canSkip(); //check if the vote to skip meets required percent now
}

/*
 *  Adds all the necessary event listeners to a client
 */
Group.prototype.addEventListeners = function(client){
    var self = this;
    
    client.on('chatMessage', function(message){
        self.sendChatMessage(client, message);
    });
    client.on('answer', function(answer){
        self.handleAnswer(client, answer);
    });
    client.on('skip', function(){
        self.voteToSkip(client, true);
    });
}

/*
 *  Receives a client, a variable name, and new value
 *  Will search for the client in the client list and edit
 *  the given property with the new given value
 */
Group.prototype.setClientProp = function(client, prop, value){
    var self = this;
    
    //search through clients to find our target
    for(var c in self.clients){
        var cObj = self.clients[c];
        
        if(c == client.id)
            cObj[prop] = value;
    }
}

/*
 *  Duh
 */
Group.prototype.setAllClientProps = function(prop, value){
    var self = this;
    
    //search through clients to find our target
    for(var c in self.clients){
        var cObj = self.clients[c];
            cObj[prop] = value;
    }
}

/*
 *  Receives a client, and the property to get
 *  Will get the client-specific property
 */
Group.prototype.getClientProp = function(client, prop){
    var self = this;
    
    //search through clients to find our target
    for(var c in self.clients){
        var cObj = self.clients[c];
        
        if(c == client.id)
            return cObj[prop];
    }

    return false;
}

/*
 *  Gets the number of ACTIVE clients
 */
Group.prototype.getClientCount = function(){
    var count = 0;
    for(var client in this.clients)
        count++;
    
    return count;
}

/*
 *  After a person leaves/joins, we want to check if we
 *  can skip the question now
 */
Group.prototype.canSkip = function(){
    //don't let them skip when there is a timer countdown already in progress!
    if(!this.betweenTimeout){
        var self = this;
        var clients = this.getClientCount();
        var votesToSkip = this.getVoteCount();
        var votePercent = (votesToSkip/clients)*100;

        //the current questionID, which we can compare to the new 
        //pulled question ID. If they match, that means this is the
        //last question for this group to answer, so they can't really
        //skip it.
        var questionID = this.currentQuestion.question.id;

        //is it greater than the required vote percentage?
        //if so, skip the question
        if(votePercent >= this.requiredVotePercentage){
            //load a new question
            this.loadNextQuestion(function(returned){
                var newQuestionID = self.currentQuestion.question.id;

                if(returned){
                    //new question successfully pulled
                    if(newQuestionID != questionID){
                        self.canSubmitAnswers = false;
                        self.endTimer();
                        self.startTimer(10);
                        self.betweenTimeout = setTimeout(function(){
                            if(self.max_time > 0)
                                self.main();

                            self.sendCurrentQuestion();
                            self.sendAnswerStats();
                            self.canSubmitAnswers = true;

                            //set "betweenTimeout" as false. there is no timer going now
                            self.betweenTimeout = false;
                        },10000);
                    }else{
                        //WHAT TO ADD HERE? SOMEHOW NOTIFY THEM THEY CAN'T SKIP THIS QUESTION,
                        //BECAUSE IT'S THEIR LAST QUESTION.
                    }
                }else{
                    self.throwError('There are no available questions to answer for this group.');
                }
            }, questionID);
        }
    }
}

/*
 *  Add vote to skip the question
 */
Group.prototype.voteToSkip = function(client){
    this.skipVotes[client.id] = true;
    this.canSkip();
}

/*
 *  Gets the number of 
 */
Group.prototype.getVoteCount = function(){
    var self = this;
    
    var count = 0;
    for(var voter in self.skipVotes) {
        if(self.skipVotes[voter])
            count++;
    }
    return count;
}

/*
 *  Takes any submitted chat messages and sends them to all clients
 *  excluding the sender
 */
Group.prototype.sendChatMessage = function(client, message){
    var self = this;
    
    var time = new Date().getTime();
    var lastChatMessage = this.getClientProp(client, 'lastChatMessage');
    
    //make sure they wait at least 3000 seconds inbetween messsages!
    if(time-lastChatMessage >= 1500){
        //send to everyone except the sender
        this.broadcast(client, 'newChatMessage', {
            username : self.clients[client.id].username,
            message : message
        });
        
        self.setClientProp(client, 'lastChatMessage', time);
        
        console.log(self.clients[client.id].username, message);
    }
}

/*
 *  Everything is processed/loaded and ready to go?
 *  Let's go! Send the first question and other init data
 */
Group.prototype.ready = function(){
    this.sendCurrentQuestion();
    this.send('ready', this.getGroupData());
    this.sendAnswerStats();
    this.main();
    
    //set group status as loaded
    this.loadedReady = true;
}

Group.prototype.startTimer = function(seconds){
    this.timer = seconds;
    this.timeInit = new Date().getTime();
    this.send('timer', seconds);
}

Group.prototype.endTimer = function(){
    this.timer = 0;
    this.timeInit = 0;
    this.send('endTimer', true);
}

Group.prototype.throwError = function(message){
    this.thrownError = message;
    this.send('anError', message);
}

/*
 *  Before we can destroy the instance, we must clear any timeouts/intervals
 */
Group.prototype.clear = function(){
    var self = this;
    
    if(typeof this.mainTimeout != 'undefined')
        clearTimeout(self.mainTimeout);
}

//export class
exports.Group = Group;